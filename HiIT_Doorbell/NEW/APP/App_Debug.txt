#include <WiFi.h>

extern void printLocalTime(bool extraData);

extern IPAddress ip;
extern IPAddress net;
extern IPAddress gw;

extern String critERR;
extern bool debugData;
extern bool haveTime;
extern bool accesspoint;
extern char apName[];
extern int httpPort;
extern int streamPort;

extern int sketchSize;
extern int sketchSpace;
extern String sketchMD5;
extern bool otaEnabled;
extern char otaPassword[];

void serialDump() {
  Serial.println();
  // Module
  Serial.printf("Name: %s\r\n", myName);
  if (haveTime) {
    Serial.print("Time: ");
    printLocalTime(true);
  }
  Serial.printf("Firmware: %s (base: %s)\r\n", myVer, baseVersion);
  float sketchPct = 100 * sketchSize / sketchSpace;
  Serial.printf("Sketch Size: %i (total: %i, %.1f%% used)\r\n", sketchSize, sketchSpace, sketchPct);
  Serial.printf("MD5: %s\r\n", sketchMD5.c_str());
  Serial.printf("ESP sdk: %s\r\n", ESP.getSdkVersion());
  if (otaEnabled) {
    if (strlen(otaPassword) != 0) {
      Serial.printf("OTA: Enabled, Password: %s\n\r", otaPassword);
    } else {
      Serial.printf("OTA: Enabled, No Password! (insecure)\n\r");
    }
  } else {
    Serial.printf("OTA: Disabled\n\r");
  }
  // Network
  if (accesspoint) {
    if (captivePortal) {
      Serial.printf("WiFi Mode: AccessPoint with captive portal\r\n");
    } else {
      Serial.printf("WiFi Mode: AccessPoint\r\n");
    }
    Serial.printf("WiFi SSID: %s\r\n", apName);
  } else {
    Serial.printf("WiFi Mode: Client\r\n");
    String ssidName = WiFi.SSID();
    Serial.printf("WiFi Ssid: %s\r\n", ssidName.c_str());
    Serial.printf("WiFi Rssi: %i\r\n", WiFi.RSSI());
    String bssid = WiFi.BSSIDstr();
    Serial.printf("WiFi BSSID: %s\r\n", bssid.c_str());
  }
  Serial.printf("WiFi IP address: %d.%d.%d.%d\r\n", ip[0], ip[1], ip[2], ip[3]);
  if (!accesspoint) {
    Serial.printf("WiFi Netmask: %d.%d.%d.%d\r\n", net[0], net[1], net[2], net[3]);
    Serial.printf("WiFi Gateway: %d.%d.%d.%d\r\n", gw[0], gw[1], gw[2], gw[3]);
  }
  Serial.printf("WiFi Http port: %i, Stream port: %i\r\n", httpPort, streamPort);
  byte mac[6];
  WiFi.macAddress(mac);
  Serial.printf("WiFi MAC: %02X:%02X:%02X:%02X:%02X:%02X\r\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  // System
  int64_t sec = esp_timer_get_time() / 1000000;
  int64_t upDays = int64_t(floor(sec / 86400));
  int upHours = int64_t(floor(sec / 3600)) % 24;
  int upMin = int64_t(floor(sec / 60)) % 60;
  int upSec = sec % 60;
  Serial.printf("System up: %" PRId64 ":%02i:%02i:%02i (d:h:m:s)\r\n", upDays, upHours, upMin, upSec);
  Serial.printf("Active streams: %i, Previous streams: %lu, Images captured: %lu\r\n", streamCount, streamsServed, imagesServed);
  Serial.printf("CPU Freq: %i MHz, Xclk Freq: %i MHz\r\n", ESP.getCpuFreqMHz(), xclk);
  Serial.printf("Heap: %i, free: %i, min free: %i, max block: %i\r\n", ESP.getHeapSize(), ESP.getFreeHeap(), ESP.getMinFreeHeap(), ESP.getMaxAllocHeap());
  if (psramFound()) {
    Serial.printf("Psram: %i, free: %i, min free: %i, max block: %i\r\n", ESP.getPsramSize(), ESP.getFreePsram(), ESP.getMinFreePsram(), ESP.getMaxAllocPsram());
  } else {
    Serial.printf("Psram: Not found; please check your board configuration.\r\n");
    Serial.printf("- High resolution/quality settings will show incomplete frames to low memory.\r\n");
  }

  Serial.println("Preferences file: ");
  dumpPrefs(SPIFFS);
  if (critERR.length() > 0) {
    Serial.printf("\r\n\r\nAn error or halt has occurred with Camera Hardware, see previous messages.\r\n");
    Serial.printf("A reboot is required to recover from this.\r\nError message: (html)\r\n %s\r\n\r\n", critERR.c_str());
  }
  Serial.println();
  return;
}

static esp_err_t dump_handler(httpd_req_t *req) {
  flashLED(75);
  Serial.println("\r\nDump requested via Web");
  serialDump();
  static char dumpOut[2000] = "";
  char *d = dumpOut;
  // Header
  d += sprintf(d, "<html><head><meta charset=\"utf-8\">\n");
  d += sprintf(d, "<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n");
  d += sprintf(d, "<title>%s - Status</title>\n", myName);
  d += sprintf(d, "<link rel=\"icon\" type=\"image/png\" sizes=\"32x32\" href=\"/favicon-32x32.png\">\n");
  d += sprintf(d, "<link rel=\"icon\" type=\"image/png\" sizes=\"16x16\" href=\"/favicon-16x16.png\">\n");
  d += sprintf(d, "<link rel=\"stylesheet\" type=\"text/css\" href=\"/style.css\">\n");
  d += sprintf(d, "</head>\n");
  d += sprintf(d, "<body>\n");
  d += sprintf(d, "<img src=\"/logo.svg\" style=\"position: relative; float: right;\">\n");
  if (critERR.length() > 0) {
    d += sprintf(d, "%s<hr>\n", critERR.c_str());
  }
  d += sprintf(d, "<h1>ESP32 Cam Webserver</h1>\n");
  // Module
  d += sprintf(d, "Name: %s<br>\n", myName);
  d += sprintf(d, "Firmware: %s (base: %s)<br>\n", myVer, baseVersion);
  float sketchPct = 100 * sketchSize / sketchSpace;
  d += sprintf(d, "Sketch Size: %i (total: %i, %.1f%% used)<br>\n", sketchSize, sketchSpace, sketchPct);
  d += sprintf(d, "MD5: %s<br>\n", sketchMD5.c_str());
  d += sprintf(d, "ESP sdk: %s<br>\n", ESP.getSdkVersion());
  // Network
  d += sprintf(d, "<h2>WiFi</h2>\n");
  if (accesspoint) {
    if (captivePortal) {
      d += sprintf(d, "Mode: AccessPoint with captive portal<br>\n");
    } else {
      d += sprintf(d, "Mode: AccessPoint<br>\n");
    }
    d += sprintf(d, "SSID: %s<br>\n", apName);
  } else {
    d += sprintf(d, "Mode: Client<br>\n");
    String ssidName = WiFi.SSID();
    d += sprintf(d, "SSID: %s<br>\n", ssidName.c_str());
    d += sprintf(d, "Rssi: %i<br>\n", WiFi.RSSI());
    String bssid = WiFi.BSSIDstr();
    d += sprintf(d, "BSSID: %s<br>\n", bssid.c_str());
  }
  d += sprintf(d, "IP address: %d.%d.%d.%d<br>\n", ip[0], ip[1], ip[2], ip[3]);
  if (!accesspoint) {
    d += sprintf(d, "Netmask: %d.%d.%d.%d<br>\n", net[0], net[1], net[2], net[3]);
    d += sprintf(d, "Gateway: %d.%d.%d.%d<br>\n", gw[0], gw[1], gw[2], gw[3]);
  }
  d += sprintf(d, "Http port: %i, Stream port: %i<br>\n", httpPort, streamPort);
  byte mac[6];
  WiFi.macAddress(mac);
  d += sprintf(d, "MAC: %02X:%02X:%02X:%02X:%02X:%02X<br>\n", mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);

  // System
  d += sprintf(d, "<h2>System</h2>\n");
  if (haveTime) {
    struct tm timeinfo;
    if (getLocalTime(&timeinfo)) {
      char timeStringBuff[50];  //50 chars should be enough
      strftime(timeStringBuff, sizeof(timeStringBuff), "%H:%M:%S, %A, %B %d %Y", &timeinfo);
      //print like "const char*"
      d += sprintf(d, "Time: %s<br>\n", timeStringBuff);
    }
  }
  int64_t sec = esp_timer_get_time() / 1000000;
  int64_t upDays = int64_t(floor(sec / 86400));
  int upHours = int64_t(floor(sec / 3600)) % 24;
  int upMin = int64_t(floor(sec / 60)) % 60;
  int upSec = sec % 60;
  // int McuTc = (temprature_sens_read() - 32) / 1.8;  // celsius
  // int McuTf = temprature_sens_read();               // fahrenheit

  d += sprintf(d, "Up: %" PRId64 ":%02i:%02i:%02i (d:h:m:s)<br>\n", upDays, upHours, upMin, upSec);
  d += sprintf(d, "Active streams: %i, Previous streams: %lu, Images captured: %lu<br>\n", streamCount, streamsServed, imagesServed);
  d += sprintf(d, "CPU Freq: %i MHz, Xclk Freq: %i MHz<br>\n", ESP.getCpuFreqMHz(), xclk);
  d += sprintf(d, "<span title=\"NOTE: Internal temperature sensor readings can be innacurate on the ESP32-c1 chipset, and may vary significantly between devices!\">");
  // d += sprintf(d, "MCU temperature : %i &deg;C, %i &deg;F</span>\n<br>", McuTc, McuTf);
  d += sprintf(d, "Heap: %i, free: %i, min free: %i, max block: %i<br>\n", ESP.getHeapSize(), ESP.getFreeHeap(), ESP.getMinFreeHeap(), ESP.getMaxAllocHeap());
  if (psramFound()) {
    d += sprintf(d, "Psram: %i, free: %i, min free: %i, max block: %i<br>\n", ESP.getPsramSize(), ESP.getFreePsram(), ESP.getMinFreePsram(), ESP.getMaxAllocPsram());
  } else {
    d += sprintf(d, "Psram: <span style=\"color:red;\">Not found</span>, please check your board configuration.<br>\n");
    d += sprintf(d, "- High resolution/quality images & streams will show incomplete frames due to low memory.<br>\n");
  }
  if ((SPIFFS.totalBytes() > 0)) {
  // if (filesystem && (SPIFFS.totalBytes() > 0)) {
    d += sprintf(d, "Spiffs: %i, used: %i<br>\n", SPIFFS.totalBytes(), SPIFFS.usedBytes());
  } else {
    d += sprintf(d, "Spiffs: <span style=\"color:red;\">No filesystem found</span>, please check your board configuration.<br>\n");
    d += sprintf(d, "- saving and restoring camera settings will not function without this.<br>\n");
  }

  // // Footer
  d += sprintf(d, "<br><div class=\"input-group\">\n");
  d += sprintf(d, "<button title=\"Instant Refresh; the page reloads every minute anyway\" onclick=\"location.replace(document.URL)\">Refresh</button>\n");
  d += sprintf(d, "<button title=\"Force-stop all active streams on the camera module\" ");
  d += sprintf(d, "onclick=\"let throwaway = fetch('stop');setTimeout(function(){\nlocation.replace(document.URL);\n}, 200);\">Kill Stream</button>\n");
  d += sprintf(d, "<button title=\"Close this page\" onclick=\"javascript:window.close()\">Close</button>\n");
  d += sprintf(d, "</div>\n</body>\n");
  // A javascript timer to refresh the page every minute.
  d += sprintf(d, "<script>\nsetTimeout(function(){\nlocation.replace(document.URL);\n}, 60000);\n");
  d += sprintf(d, "</script>\n</html>\n");
  *d++ = 0;
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Content-Encoding", "identity");
  return httpd_resp_send(req, dumpOut, strlen(dumpOut));
}

static esp_err_t error_handler(httpd_req_t *req) {
  flashLED(75);
  Serial.println("Sending error page");
  std::string s(error_html);
  size_t index;
  while ((index = s.find("<APPURL>")) != std::string::npos)
    s.replace(index, strlen("<APPURL>"), httpURL);
  while ((index = s.find("<CAMNAME>")) != std::string::npos)
    s.replace(index, strlen("<CAMNAME>"), myName);
  while ((index = s.find("<ERRORTEXT>")) != std::string::npos)
    s.replace(index, strlen("<ERRORTEXT>"), critERR.c_str());
  httpd_resp_set_type(req, "text/html");
  httpd_resp_set_hdr(req, "Content-Encoding", "identity");
  return httpd_resp_send(req, (const char *)s.c_str(), s.length());
}